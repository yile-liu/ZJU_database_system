# 项目分工

刘思锐：DIsk Manager, Table Heap, B+ Tree（部分）, Executor（部分）

张洮莼：Buffer Pool Manager, B+ Tree（部分）, Executor（部分）

罗鸣明：Catalog Manager, Record Manager, Executor（部分）

# 项目整体报告

## 1 项目架构

在系统架构中，解释器`SQL Parser`在解析SQL语句后将生成的语法树交由执行器`Executor`处理。执行器则根据语法树的内容对相应的数据库实例（`DB Storage Engine Instance`）进行操作。

每个`DB Storage Engine Instance`对应了一个数据库实例（即通过`CREATE DATABSAE`创建的数据库）。在每个数据库实例中，用户可以定义若干表和索引，表和索引的信息通过`Catalog Manager`、`Index Manager`和`Record Manager`进行维护。

<img src="/Users/yileliu/Downloads/模块设计报告.assets/image-20220611193317405.png" alt="image-20220611193317405" style="zoom:40%;" />

## 2 Main

生成语法树由Parser模块负责，而Parser由课程组给出不要求掌握。顶层模块我们对原框架的主要改动在于加入额外的判断和循环以支持Execfile语句。

<img src="/Users/yileliu/Downloads/模块设计报告.assets/image-20220611194656347.png" alt="image-20220611194656347" style="zoom:40%;" />

## 3 Executor

Executor中我们将节点分为两类：顶层节点和内部节点。

- 顶层节点指原框架中给出的，与SQL语句一一对应的执行节点。其又可以分为含条件的和不含条件的两类。
  - 含条件的节点指Select、Update、Delete三个可以用where语句筛选tuple的节点。
  - 剩余的节点是不含条件的节点。
- 内部节点为我们自己新增的节点类型，以递归调用的形式为含条件的顶层节点返回符合条件的row_id。

<img src="/Users/yileliu/Downloads/模块设计报告.assets/image-20220611200245343.png" alt="image-20220611200245343" style="zoom:50%;" />

下面用伪代码的形式介绍Executor中各节点类型的执行流程。

### Database

```cpp
dberr_t ExecuteEngine::ExecuteCreateDatabase(pSyntaxNode ast, ExecuteContext *context) {
  char *DB_name = ast->child_->val_;
  if (DB_name exists) {
    return DB_FAILED;
  } else {
    auto DB_ptr = new DBStorageEngine(DB_name, true);
    dbs_.insert(make_pair(DB_name, DB_ptr));
    return DB_SUCCESS;
  }
}

dberr_t ExecuteEngine::ExecuteDropDatabase(pSyntaxNode ast, ExecuteContext *context) {
  char *DB_name = ast->child_->val_;
  dbs_.erase(DB_name);
  return DB_SUCCESS;
}

dberr_t ExecuteEngine::ExecuteShowDatabases(pSyntaxNode ast, ExecuteContext *context) {
  if (dbs_.empty()) {
    cout << "Empty!" << endl;
    return DB_FAILED;
  }
	print(dbs_);
  return DB_SUCCESS;
}

dberr_t ExecuteEngine::ExecuteUseDatabase(pSyntaxNode ast, ExecuteContext *context) {
  string DB_name = ast->child_->val_;
  if (DB_name exists) {
    current_db_ = DB_name;
    return DB_SUCCESS;
  } else {
    return DB_FAILED;
  }
}
```

### Table

```c++
dberr_t ExecuteEngine::ExecuteShowTables(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) { // no database is used
    return DB_FAILED;
  }
  if (dbs_[current_db_]->catalog_mgr_->GetTables(tables) == DB_TABLE_NOT_EXIST) { // no table
    return DB_FAILED;
  }
	print(tables);
  return DB_SUCCESS;
}


dberr_t ExecuteEngine::ExecuteCreateTable(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  
  pSyntaxNode ast_ptr = ast->child_->next_->child_;
  while (ast_ptr != nullptr) {
		// update columns info from ast_ptr
    ast_ptr = ast_ptr->child_;
  }
  
  Schema *schema = new Schema(*columns);
  TableInfo *table_info;
  dberr_t result = 
    dbs_[current_db_]->catalog_mgr_->CreateTable(context->table_name_, schema, nullptr, table_info);
  switch (result) {
    case DB_SUCCESS:
			// 1. update table_info in catalog manager
			// 2. create index for unique columns
      // 3. update index_info in catalog manager
    default:
      print(failure info);
      return result;
  }
}


dberr_t ExecuteEngine::ExecuteDropTable(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  string table_name = ast->child_->val_;
  if (ast->child_->val_ != nullptr) {
    dberr_t result = dbs_[current_db_]->catalog_mgr_->DropTable(table_name);
    if (result == DB_TABLE_NOT_EXIST) {
      return DB_FAILED;
    } else if (result == DB_SUCCESS) {
      // update table_info in catalog manager
      return DB_SUCCESS;
    }
  }
}
```

### Index

```cpp
dberr_t ExecuteEngine::ExecuteShowIndexes(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  if (dbs_[current_db_]->catalog_mgr_->GetTables(tables) == DB_FAILED) {
    return DB_FAILED;
  }
  vector<vector<IndexInfo *>> indexes_of_table_;
  for (uint i = 0; i < tables.size(); i++) {
    dbs_[current_db_]->catalog_mgr_->GetTableIndexes(tables[i]->GetTableName(), indexes_of_table_[i]);
  }
  print(table_name, indexes_of_table);
  return DB_SUCCESS;
}

dberr_t ExecuteEngine::ExecuteCreateIndex(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  
  // 1. check if table name exists
  // 2. check if column names exist
  // 3. traverse all tuples in table to check if the data is unique
  // 4. if 1~3 satisfied, create index using interfaces of B+TreeIndex part
  // 5. update index_info in catalog manager
}

dberr_t ExecuteEngine::ExecuteDropIndex(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  if (dbs_[current_db_]->catalog_mgr_->GetTables(tables) == DB_FAILED) {
    return DB_FAILED;
  }
  
  string index_name(ast->child_->val_);
  if (context->rows_num > 0) {
    // update table_info in catalog manager
    return DB_SUCCESS;
  } else {
    cout << "Index '" << context->index_name << "' doesn't exist" << endl;
    return DB_FAILED;
  }
}
```

### Tuple

```cpp
dberr_t ExecuteEngine::ExecuteInsert(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  
  // 1. check if table name exists
  // 2. check if values match their own columns
  // 3. check if it against index uniqueness
  // 4. if 1~3 satisfied, insert it using interfaces of table heap
}


dberr_t ExecuteEngine::ExecuteDelete(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  context->table_name_ = ast->child_->val_;
  if (DB_storage_engine->catalog_mgr_->GetTable(context->table_name_, table_info) == DB_TABLE_NOT_EXIST) {
    return DB_FAILED;
  }
  
  if (ast->child_->next_ != nullptr) {
    // 有condition
    res = ExecuteInternalNode(ast->child_->next_->child_, context);
    // find needed tuples' row_id, returned in context
    if (res == DB_SUCCESS) {
			// delete all tuple in context using interface of table heap
    }
    return res;
  } else {
    // 无condition
    for (all tuples in table heap) {
      // delete all using interface of table heap
    }
  }
  return DB_SUCCESS:
}

dberr_t ExecuteEngine::ExecuteUpdate(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  }
  context->table_name_ = ast->child_->val_;
  if (DB_storage_engine->catalog_mgr_->GetTable(context->table_name_, table_info) == DB_TABLE_NOT_EXIST) {
    return DB_FAILED;
  }
  
  if (ast->child_->next_ != nullptr) {
    res = ExecuteInternalNode(ast->child_->next_->child_, context);
    // find needed tuples' row_id, returned in context
    if (res == DB_SUCCESS) {
			// update all tuple in context using interface of table heap
    }
    return res;
  }
  return DB_FAILED;
}
```

### Select

```cpp
dberr_t ExecuteEngine::ExecuteSelect(pSyntaxNode ast, ExecuteContext *context) {
  if (current_db_.empty()) {
    return DB_FAILED;
  } else if (dbs_.find(current_db_) == dbs_.end()) {
    return DB_FAILED;
  }
  
  if (table exists) {
    res = ExecuteInternalNode(ast->child_, context);
		// try get what columns is needed
    if (!ast->child_->next_->next_) {
			// no condition
      print(table);
      return DB_SUCCESS;
    } else {
      // get rowid satisfied conditions in context
      res = ExecuteInternalNode(ast->child_->next_->next_->child_, context);
      if (res == DB_SUCCESS) {
        print(result in context);
      } else {
        return res;
      }
    }
  }
  return DB_FAILED;
}
```

### Internal Node

```cpp
dberr_t ExecuteEngine::ExecuteInternalNode(pSyntaxNode ast, ExecuteContext *context) {
  switch (ast->type_) {
    case kNodeColumnDefinition:
      // get column list and update context with for() loop
      break;
      
    case kNodeConnector:
      ExecuteInternalNode(ast->child_, context);
      temp_res_1 = context.internal_result_rid_;
      ExecuteInternalNode(ast->child_->next, context);
      temp_res_2 = context.internal_result_rid_;
      if(connector == "and")
        context->internal_result_rid_ = union(temp_res_1, tep_res_2);
      else if(connector == "or")
        context->internal_result_rid_ = intersection(temp_res_1, tep_res_2);
      break;
      
    case kNodeCompareOperator:
      switch(operation){
        case "=":
          for(each tuple in table heap)
            if(tuple satisfiled condition)
              context->temp_res.emplace_back(this tuple);
        case ">" :
          ...
      }
      break;
      
    case kNodeAllColumns:
      // recursion for case kNodeColumnDefinition
      // add all columns in this table into context
      break;
      
    case kNodeColumnList:
      // recursion for case kNodeColumnDefinition
      // read list and add into context
      break;
      
    default:
      cerr << endl << "ExecuteInternalNode: Invalid internal node type!" << endl;
      return DB_FAILED;
  }
}
```

## 4 Catalog Manager

Catalog Manager 管理和维护数据库中的所有表和索引的信息，主要包括`表信息(TableInfo)`和`索引信息(IndexInfo)`两种，每种信息中包含了名称、字段、主键等定义。该模块调用下层接口实现创建、更新、删除等功能，并为上层的执行器`Executor`提供接口。

表和索引的信息中最核心的部分是表和索引的元信息，根据元信息可以生成或恢复整个表和索引信息，所以在创建和后续重新打开数据库实例恢复信息时主要需要得到元信息，因此对相关元信息实现序列化和反序列化操作。

在`CatalogManager`、`TableInfo`、`IndexInfo`中都通过各自的`heap`维护和管理与自身相关的内存分配和回收，在析构时，其相关对象会跟随一起析构，而不需要手动管理。类之间的管理关系如下。

<img src="模块设计报告.assets/image-20220612164752646.png" alt="image-20220612164752646" style="zoom:50%;" />

索引需要在表的基础上建立，因此索引信息类中包含了表信息，要先创建了表之后才能创建索引。而在删除表时，需要先删除该表的所有索引之后，才能删除该表。

Catalog Manager中的表和索引的信息用C++中的map容器存放，通过表名或索引名可以查到其id，通过id可以查找存放表和索引数据的page_id。

```cpp
  std::map<table_id_t, page_id_t> table_meta_pages_;
  std::map<index_id_t, page_id_t> index_meta_pages_;
```

Catalog Manager对上层模块提供了一些接口，方便执行器获取目录信息并生成执行计划：

* `CatalogManager::CreateTable`: 通过表名和schema生成TableInfo；
* `CatalogManager::GetTable:` 通过表名得到TableInfo；
* `CatalogManager::GetTables`: 获取包含所有数据表的vector；
* `CatalogManager::CreateIndex`: 通过表名、索引名和表与索引的映射关系生成IndexInfo；
* `CatalogManager::GetIndex:`：通过索引名得到IndexInfo；
* `CatalogManager::DropTable`: 通过表名删除TableInfo和CatalogManger中的相关表信息；
* `CatalogManager::DropIndex`: 通过索引名删除Indexinfo和CatalogManager中的相关索引信息。

## 5 B+ Tree Manager

Index Manager 负责数据表索引的实现和管理，包括：索引的创建和删除，索引键的等值查找，索引键的范围查找（返回对应的迭代器），以及插入和删除键值等操作，并对外提供相应的接口。

在堆表实验中，能够发现，通过遍历堆表的方式来查找一条记录是十分低效的。为了能够快速定位到某条记录而无需搜索数据表中的每一条记录，我们需要在上一个实验的基础上实现一个索引，这能够为快速随机查找和高效访问有序记录提供基础。索引有很多种实现方式，如B+树索引，Hash索引等等。在本实验中，我们需要实现一个基于磁盘的B+树动态索引结构。

- B+树数据页
  - BPlusTreePage
  - BPlusTreeInternalPage
  - BPlusTreeLeafPage
  - KeyType、ValueType & KeyComparator

- B+树索引

在完成B+树结点的数据结构设计后，接下来需要完成B+树的创建、插入、删除、查找和释放等操作。

包括：`IsEmpty()` , `GetValue()` , `Insert()` , `StartNewTree()` , `InsertIntoLeaf()` , `Split()` , `InsertIntoParent()` , `Remove()` , `CoalesceOrRedistribute()` , `FindSibling()` , `Coalesce()` , `Redistribute()` , `AdjustRoot()` 等函数。

- B+树索引迭代器

在B+树索引中实现`Begin()`和`End()`函数以获取B+树索引的首迭代器和尾迭代器。

- B+树操作

`INSERT`：在对B+树插入新数据时，会调用到 `Insert()`函数，该函数的逻辑是，如果要插入的B+树是空树，则创建一颗新树，如果不是空树，则调用`InsertIntoLeaf()`函数，即根据`Key`找到对应的叶子节点，并插入到该叶子节点。

`SPLIT`: 在调用`InsertIntoLeaf()`函数时，如果插入后的叶子节点个数大于`max_size`，则需要对该叶子节点进行`Split()`函数，其逻辑是调用`MoveHalfTo()`函数生成两个大小一样或相差为1的叶子节点，并对父亲进行维护，如果父亲也超过`max_size`，当父亲是中间节点时，继续调用`Split()`函数，当父亲是根节点时，调用`AdjustRoot()`函数来对根节点进行调整。

`REMOVE`: 删除B+树中的数据时，会调用到`Remove()`函数，该函数先删除`Key`对应的记录，如果该节点小于`min_size`，则调用`CoalesceOrRedistribute()`函数，对叶子节点进行重分配或者合并。

- B+树数据处理

B+树是使用模板构造的函数，`int`,`float`,`char`三种类型的值都可以转变为`Generic_key`，从而在B+树中进行操作和索引。叶子节点中的`Value`是指向表中对应的`RowId`值，从而能够通过B+树数据处理在表中用索引快速找到某条记录。

## 6 Record Manager

Record Manager负责管理数据表中所有的记录，包括`列(Column)`、`模式(Schema)`、`域(Field)`、`行(Row)`，它可以支持这些记录的插入、删除和查找操作，并且对外提供相应的接口。为了能够持久化这些记录，我们需要将这些对象序列化成`字节流(char*)`的方法，为了从磁盘中恢复这些对象，我们需要从字节流反序列化恢复这些记录对象。同时我们具体通过堆表进行记录的管理。、

四种记录中，`field`是最基础的，对应于一条记录中某一个字段的数据信息。`column`用于定义和表示数据表中的某一个字段，包含字段名、字段类型、是否唯一等。`schema`由多个column组成，表示表或索引的结构，而`row`与元组的概念等价，用于存储记录或索引键。

下面用一个示意图表示他们的关系：

![struct](../Desktop/minisql/pic\struct.jpg)

通过Record Manager模块的设计，我们可以向表中插入、删除和查找记录。其中：

* `TableHeap::InsertTuple(&row,*txn)`: 向数据表中插入一个row；
* `TableHeap::MarkDelete(&rid,*txn)`: 将数据表中的一个row标记为被删除；
* `TableHeap::UpdateTuple(&new_row,&rid,*txn)`: 用新的row更新已有的row；
* `TableHeap::GetTuple(*row,*txn)`: 在数据表中读一个row。

## 7 Buffer Pool Manager

Buffer Pool Replacer负责跟踪Buffer Pool中数据页的使用情况，并在Buffer Pool没有空闲页时决定替换哪一个数据页。在本节中，需要实现一个基于LRU替换算法的`LRUReplacer`，其扩展了抽象类`Replacer`。`LRUReplacer`的大小默认与Buffer Pool的大小相同。

通过LRUReplacer模块的设计，我们利用LRU替换算法实现了跟踪Buffer Pool中数据页的使用情况并在Buffer Pool没有空闲页时决定替换哪一个数据页。其中：

- `LRUReplacer::Victim(*frame_id)`：替换（即删除）与所有被跟踪的页相比最近最少被访问的页，将其页帧号（即数据页在Buffer Pool的Page数组中的下标）存储在输出参数`frame_id`中输出并返回`true`，如果当前没有可以替换的元素则返回`false`；
- `LRUReplacer::Pin(frame_id)`：将数据页固定使之不能被`Replacer`替换，即从`lru_list_`中移除该数据页对应的页帧。`Pin`函数应当在一个数据页被Buffer Pool Manager固定时被调用；
- `LRUReplacer::Unpin(frame_id)`：将数据页解除固定，放入`lru_list_`中，使之可以在必要时被`Replacer`替换掉。`Unpin`函数应当在一个数据页的引用计数变为`0`时被Buffer Pool Manager调用，使页帧对应的数据页能够在必要时被替换；
- `LRUReplacer::Size()`：此方法返回当前`LRUReplacer`中能够被替换的数据页的数量。

在实现Buffer Pool的替换算法`LRUReplacer`后，需要实现整个`BufferPoolManager`。Buffer Pool Manager负责从Disk Manager中获取数据页并将它们存储在内存中，并在必要时将脏页面转储到磁盘中（如需要为新的页面腾出空间）。

数据库系统中，所有内存页面都由`Page`对象表示，每个`Page`对象都包含了一段连续的内存空间`data_`和与该页相关的信息（如是否是脏页，页的引用计数等等）。注意，`Page`对象并不作用于唯一的数据页，它只是一个用于存放从磁盘中读取的数据页的容器。这也就意味着同一个`Page`对象在系统的整个生命周期内，可能会对应很多不同的物理页。`Page`对象的唯一标识符`page_id_`用于跟踪它所包含的物理页，如果`Page`对象不包含物理页，那么`page_id_`必须被设置为`INVALID_PAGE_ID`。每个`Page`对象还维护了一个计数器`pin_count_`，它用于记录固定(Pin)该页面的线程数。Buffer Pool Manager将不允许释放已经被固定的`Page`。每个`Page`对象还将记录它是否脏页，在复用`Page`对象之前必须将脏的内容转储到磁盘中。

在`BufferPoolManager`的实现中，需要用到此前已经实现的`LRUReplacer`或是其它的`Replacer`，它将被用于跟踪`Page`对象何时被访问，以便`BufferPoolManager`决定在Buffer Pool中没有空闲页可以用于分配时替换哪个数据页。

BufferPoolManager模块的功能是实现在缓冲池中向内存取页及刷页。

- `BufferPoolManager::FetchPage(page_id)`：根据逻辑页号获取对应的数据页，如果该数据页不在内存中，则需要从磁盘中进行读取；
- `BufferPoolManager::NewPage(&page_id)`：分配一个新的数据页，并将逻辑页号于`page_id`中返回；
- `BufferPoolManager::UnpinPage(page_id, is_dirty)`：取消固定一个数据页；
- `BufferPoolManager::FlushPage(page_id)`：将数据页转储到磁盘中；
- `BufferPoolManager::DeletePage(page_id)`：释放一个数据页；
- `BufferPoolManager::FlushAllPages()`：将所有的页面都转储到磁盘中。

## 8 Disk Manager

实验中我们使用Disk Meta Page -> Bitmap Meta Page -> Bitmap Page三层级的文件结构，其中只有Bitmap Page储存实例数据。Disk Manager需要实现从物理页号到逻辑页号的映射管理。磁盘中每一个页的大小都是4KB。

<img src="/Users/yileliu/Downloads/模块设计报告.assets/image-20220611215909687.png" alt="image-20220611215909687" style="zoom:33%;" />

这带来了逻辑页号与物理页号不统一的问题。

<img src="/Users/yileliu/Downloads/模块设计报告.assets/image-20220611215950299.png" alt="image-20220611215950299" style="zoom:50%;" />

DiskManager需要负责维护Disk Meta Page 与 Bitmap Meta Page 内容的更新，并向上层隐藏文件的内部结构。上层只需要关注逻辑页号，而不需要获得物理页号和Meta的相关信息。

- `void ReadPage(page_id_t logical_page_id, char *page_data)`：将data写入某个逻辑页号；
- `void WritePage(page_id_t logical_page_id, const char *page_data)` ：从某个逻辑页号读出data；
- `page_id_t AllocatePage()`：分配一个逻辑页；
- `void DeAllocatePage(page_id_t logical_page_id)`：释放一个逻辑页；
- `bool IsPageFree(page_id_t logical_page_id)`：判断某个逻辑页号是否已经被分配。

# 模块设计报告

## 1 Disk Manager

### 1.1 实验目的

Disk Manager主要负责数据库文件中数据页的分配和回收，以及数据页中数据的读取和写入。其中，数据页的分配和回收通过位图（Bitmap）这一数据结构实现，位图中每个比特（Bit）对应一个数据页的分配情况，用于标记该数据页是否空闲。

实验中我们使用Disk Meta Page -> Bitmap Meta Page -> Bitmap Page三层级的文件结构，其中只有Bitmap Page储存实例数据。Disk Manager需要实现从物理页号到逻辑页号的映射管理。

### 1.2 实验细节

#### 1.2.1 模块设计细节

- 构造函数

  ```cpp
  DiskManager::DiskManager(const std::string &db_file) : file_name_(db_file) {
    std::scoped_lock<std::recursive_mutex> lock(db_io_latch_);
    db_io_.open(db_file, std::ios::binary | std::ios::in | std::ios::out);
    // directory or file does not exist
    if (!db_io_.is_open()) {
      db_io_.clear();
      // create a new file
      db_io_.open(db_file, std::ios::binary | std::ios::trunc | std::ios::out);
      db_io_.close();
      // reopen with original mode
      db_io_.open(db_file, std::ios::binary | std::ios::in | std::ios::out);
      if (!db_io_.is_open()) {
        throw std::exception();
      }
    }
    ReadPhysicalPage(META_PAGE_ID, meta_data_);
    meta_page = reinterpret_cast<DiskFileMetaPage *>(meta_data_);
  }
  ```

- AllocatePage函数

  ```cpp
  page_id_t DiskManager::AllocatePage() {
    char open_page[PAGE_SIZE];
    BitmapPage<PAGE_SIZE> *bitmap;
    uint32_t offset_in_bitmap;
    // 尝试从现有的bitmap找未使用的空间
    for (unsigned int i = 0; i < meta_page->GetExtentNums(); ++i) {
      ReadPhysicalPage(i * (BITMAP_SIZE + 1) + 1, open_page);
      bitmap = reinterpret_cast<BitmapPage<PAGE_SIZE> *>(open_page);
      if (bitmap->AllocatePage(offset_in_bitmap)) {
        ++meta_page->num_allocated_pages_;
        ++meta_page->extent_used_page_[i];
        WritePhysicalPage(i * (BITMAP_SIZE + 1) + 1, open_page);
        return offset_in_bitmap + i * BITMAP_SIZE;
      }
    }
    // 现有bitmap下辖的数据页都没有空间，新建一个bitmap用于分配空间并更新meta_page
    ++meta_page->num_extents_;
    for (int i = 0; i < PAGE_SIZE; ++i) {
      open_page[i] = 0x0;
    }
    bitmap = reinterpret_cast<BitmapPage<PAGE_SIZE> *>(open_page);
    if (bitmap->AllocatePage(offset_in_bitmap)) {
      ++meta_page->num_allocated_pages_;
      ++meta_page->extent_used_page_[meta_page->num_extents_ - 1];
      WritePhysicalPage((1 + BITMAP_SIZE) * (meta_page->GetExtentNums() - 1) + 1, open_page);
      WritePhysicalPage(META_PAGE_ID, reinterpret_cast<const char *>(meta_page));
      return offset_in_bitmap + (meta_page->GetExtentNums() - 1) * BITMAP_SIZE;
    }
    WritePhysicalPage(META_PAGE_ID, reinterpret_cast<const char *>(meta_page));
    return INVALID_PAGE_ID;
  }
  ```

- 逻辑页号到物理页号的转换函数

  ```cpp
  inline page_id_t DiskManager::MapPageId(page_id_t logical_page_id) {
    return (logical_page_id / BITMAP_SIZE) * (BITMAP_SIZE + 1) + logical_page_id % BITMAP_SIZE + 2;
  }
  ```

#### 1.2.2 模块结构

- DiskManager类

  ```cpp
  class DiskManager {
  public:
    explicit DiskManager(const std::string &db_file);
  
    ~DiskManager() {
      if (!closed) {
        Close();
      }
    }
  
    void ReadPage(page_id_t logical_page_id, char *page_data);
  
    void WritePage(page_id_t logical_page_id, const char *page_data);
  
    page_id_t AllocatePage();
  
    void DeAllocatePage(page_id_t logical_page_id);
  
    bool IsPageFree(page_id_t logical_page_id);
  
    void Close();
  
    char *GetMetaData() {
      return meta_data_;
    }
  
    static constexpr size_t BITMAP_SIZE = BitmapPage<PAGE_SIZE>::GetMaxSupportedSize();
  
  private:
  
    int GetFileSize(const std::string &file_name);
  
    void ReadPhysicalPage(page_id_t physical_page_id, char *page_data);
  
    void WritePhysicalPage(page_id_t physical_page_id, const char *page_data);
    
    page_id_t MapPageId(page_id_t logical_page_id);
  
  private:
    // stream to write db file
    std::fstream db_io_;
    std::string file_name_;
    // with multiple buffer pool instances, need to protect file access
    std::recursive_mutex db_io_latch_;
    bool closed{false};
    char meta_data_[PAGE_SIZE];
    // 在原版基础上新加了这一个属性，方便使用
    DiskFileMetaPage *meta_page;
  };
  ```

#### 1.2.3 模块功能

DiskManager为上层模块读写磁盘提供了统一的底层接口。

- `void ReadPage(page_id_t logical_page_id, char *page_data)`：将data写入某个逻辑页号；
- `void WritePage(page_id_t logical_page_id, const char *page_data)` ：从某个逻辑页号读出data；
- `page_id_t AllocatePage()`：分配一个逻辑页；
- `void DeAllocatePage(page_id_t logical_page_id)`：释放一个逻辑页；
- `bool IsPageFree(page_id_t logical_page_id)`：判断某个逻辑页号是否已经被分配。

## 2 LRU Replacer

### 2.1 实验目的

​	Buffer Pool Replacer负责跟踪Buffer Pool中数据页的使用情况，并在Buffer Pool没有空闲页时决定替换哪一个数据页。在本节中，需要实现一个基于LRU替换算法的`LRUReplacer`，其扩展了抽象类`Replacer`。`LRUReplacer`的大小默认与Buffer Pool的大小相同。

### 2.2 实验细节

#### 2.2.1 模块设计细节

- 构造函数

```c++
LRUReplacer::LRUReplacer(size_t num_pages) {
  max_size_ = num_pages;
  in_size_ = 0;
}
```

- Victim函数

```c++
bool LRUReplacer::Victim(frame_id_t *frame_id) {
  if (!in_size_) {
    return false;
  }
  //  链表末尾是最不常被访问的页，通过*frame_id返回这一页
  *frame_id = lru_list_.back();
  //  通过map里面储存的迭代器在lru_list_里删除掉这一页
  lru_list_.erase(map_[*frame_id]);
  //  在map里删除这一页
  map_.erase(*frame_id);
  --in_size_;
  return true;
}
```

- Pin函数

```c++
void LRUReplacer::Pin(frame_id_t frame_id) {
  //  如果能找到
  if (map_.find(frame_id) != map_.end()) {
    lru_list_.erase(map_[frame_id]);
    map_.erase(frame_id);
    --in_size_;
  }
}
```

- Unpin函数

```c++
void LRUReplacer::Unpin(frame_id_t frame_id) {
  //  如果该页已经在lrureplacer里面了或者in_size_已经等于max_size_，则return
  if (map_.find(frame_id) != map_.end() || in_size_ >= max_size_) return;
  lru_list_.push_front(frame_id);
  map_[frame_id] = lru_list_.begin();
  ++in_size_;
}
```

- Size函数

```c++
size_t LRUReplacer::Size() { return in_size_; }
```

#### 2.2.2 模块结构

- Replacer 基类

```c++
class Replacer {
public:
  Replacer() = default;

  virtual ~Replacer() = default;

  virtual bool Victim(frame_id_t *frame_id) = 0;

  virtual void Pin(frame_id_t frame_id) = 0;

  virtual void Unpin(frame_id_t frame_id) = 0;

  virtual size_t Size() = 0;
};
```

- LRUReplacer 派生类

```c++
class LRUReplacer : public Replacer {
public:
  explicit LRUReplacer(size_t num_pages);

  ~LRUReplacer() override;

  bool Victim(frame_id_t *frame_id) override;

  void Pin(frame_id_t frame_id) override;

  void Unpin(frame_id_t frame_id) override;

  size_t Size() override;

private:
  size_t max_size_;
  size_t in_size_;
  std::list<frame_id_t > lru_list_;
  std::unordered_map<frame_id_t ,std::list<frame_id_t >::iterator > map_;
};
```

#### 2.2.3 模块功能

​	通过LRUReplacer模块的设计，我们利用LRU替换算法实现了跟踪Buffer Pool中数据页的使用情况并在Buffer Pool没有空闲页时决定替换哪一个数据页。其中：

- `LRUReplacer::Victim(*frame_id)`：替换（即删除）与所有被跟踪的页相比最近最少被访问的页，将其页帧号（即数据页在Buffer Pool的Page数组中的下标）存储在输出参数`frame_id`中输出并返回`true`，如果当前没有可以替换的元素则返回`false`；

- `LRUReplacer::Pin(frame_id)`：将数据页固定使之不能被`Replacer`替换，即从`lru_list_`中移除该数据页对应的页帧。`Pin`函数应当在一个数据页被Buffer Pool Manager固定时被调用；
- `LRUReplacer::Unpin(frame_id)`：将数据页解除固定，放入`lru_list_`中，使之可以在必要时被`Replacer`替换掉。`Unpin`函数应当在一个数据页的引用计数变为`0`时被Buffer Pool Manager调用，使页帧对应的数据页能够在必要时被替换；
- `LRUReplacer::Size()`：此方法返回当前`LRUReplacer`中能够被替换的数据页的数量。

## 3 Buffer Pool Manager

### 3.1 实验目的

​	在实现Buffer Pool的替换算法`LRUReplacer`后，需要实现整个`BufferPoolManager`。Buffer Pool Manager负责从Disk Manager中获取数据页并将它们存储在内存中，并在必要时将脏页面转储到磁盘中（如需要为新的页面腾出空间）。

​	数据库系统中，所有内存页面都由`Page`对象表示，每个`Page`对象都包含了一段连续的内存空间`data_`和与该页相关的信息（如是否是脏页，页的引用计数等等）。注意，`Page`对象并不作用于唯一的数据页，它只是一个用于存放从磁盘中读取的数据页的容器。这也就意味着同一个`Page`对象在系统的整个生命周期内，可能会对应很多不同的物理页。`Page`对象的唯一标识符`page_id_`用于跟踪它所包含的物理页，如果`Page`对象不包含物理页，那么`page_id_`必须被设置为`INVALID_PAGE_ID`。每个`Page`对象还维护了一个计数器`pin_count_`，它用于记录固定(Pin)该页面的线程数。Buffer Pool Manager将不允许释放已经被固定的`Page`。每个`Page`对象还将记录它是否脏页，在复用`Page`对象之前必须将脏的内容转储到磁盘中。

​	在`BufferPoolManager`的实现中，需要用到此前已经实现的`LRUReplacer`或是其它的`Replacer`，它将被用于跟踪`Page`对象何时被访问，以便`BufferPoolManager`决定在Buffer Pool中没有空闲页可以用于分配时替换哪个数据页。

### 3.2 实验细节

#### 3.2.1 模块设计细节

- 构造函数

```c++
BufferPoolManager::BufferPoolManager(size_t pool_size, DiskManager *disk_manager)
    : pool_size_(pool_size), disk_manager_(disk_manager) {
  pages_ = new Page[pool_size_];
  replacer_ = new LRUReplacer(pool_size_);
  for (size_t i = 0; i < pool_size_; i++) {
    free_list_.emplace_back(i);
  }
}
```

- FetchPage函数

```c++
Page *BufferPoolManager::FetchPage(page_id_t page_id) {
  // 1.     Search the page table for the requested page (P).
  // 1.1    If P exists, pin it and return it immediately.
  if (page_table_.find(page_id) != page_table_.end()) {
    frame_id_t frame_id;
    frame_id = page_table_[page_id];
    replacer_->Pin(frame_id);
    ++pages_[frame_id].pin_count_;
    return &pages_[frame_id];
  }
  // 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.
  //        Note that pages are always found from the free list first.
  frame_id_t frame_id;
  if (!free_list_.empty()) {
    frame_id = free_list_.back();
    free_list_.pop_back();
  } else {
    replacer_->Victim(&frame_id);
  }
  // 2.     If R is dirty, write it back to the disk.
  if (pages_[frame_id].IsDirty()) {
    FlushPage(pages_[frame_id].page_id_);
    pages_[frame_id].is_dirty_ = false;
  }
  // 3.     Delete R from the page table and insert P.
  page_table_.erase(pages_[frame_id].page_id_);
  page_table_[page_id] = frame_id;
  // 4.     Update P's metadata, read in the page content from disk, and then return a pointer to P.
  pages_[frame_id].page_id_ = page_id;
  pages_[frame_id].pin_count_ += 1;
  pages_[frame_id].ResetMemory();
  disk_manager_->ReadPage(page_id, pages_[frame_id].GetData());
  return &pages_[frame_id];
}
```

- NewPage函数

```c++
Page *BufferPoolManager::NewPage(page_id_t &page_id) {
  // 0.   Make sure you call AllocatePage!
  frame_id_t frame_id;
  // 1.   If all the pages in the buffer pool are pinned, return nullptr.
  if (free_list_.empty() && !replacer_->Victim(&frame_id)) {
    return nullptr;
  }
  // 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.
  else {
    page_id = AllocatePage();
    if (!free_list_.empty()) {
      frame_id = free_list_.back();
      free_list_.pop_back();
    } else {
      replacer_->Victim(&frame_id);
    }
  }
  // 3.   Update P's metadata, zero out memory and add P to the page table.
  page_table_[page_id] = frame_id;
  pages_[frame_id].ResetMemory();
  // 4.   Set the page ID output parameter. Return a pointer to P.
  pages_[frame_id].page_id_ = page_id;
  pages_[frame_id].pin_count_ = 1;
  pages_[frame_id].is_dirty_ = true;

#ifdef OUTPUT_PAGE_ID_FOR_DEBUG
  cout << "BufferPoolManager::NewPage " << page_id << endl;
#endif

  return &pages_[frame_id];
}
```

- UnpinPage函数

```c++
bool BufferPoolManager::UnpinPage(page_id_t page_id, bool is_dirty) {
  //  找不到page，return false
  if (page_table_.find(page_id) == page_table_.end()) {
    return false;
  }
  //  能找到，将其Unpin
  frame_id_t frame_id;
  frame_id = page_table_[page_id];
  //  异常情况
  if (pages_[frame_id].pin_count_ < 0) {
    return false;
  }
  //  正被调用，减少一个线程
  if (pages_[frame_id].pin_count_ > 0) {
    --pages_[frame_id].pin_count_;
  }
  //  未被调用，加入replacer_
  if (pages_[frame_id].pin_count_ == 0) {
    replacer_->Unpin(frame_id);
  }
  //  设置is_dirty_
  if (is_dirty) {
    pages_[frame_id].is_dirty_ = true;
    FlushPage(page_id);
  }
  return true;
}
```

- FlushPage函数

```c++
bool BufferPoolManager::FlushPage(page_id_t page_id) {
  //  找不到page，return false
  if (page_table_.find(page_id) == page_table_.end()) {
    return false;
  }
  //  找得到，将其写入磁盘
  frame_id_t frame_id;
  frame_id = page_table_[page_id];
  disk_manager_->WritePage(page_id, pages_[frame_id].GetData());
  pages_[frame_id].is_dirty_ = false;

  return true;
}
```

- DeletePage函数

```c++
bool BufferPoolManager::DeletePage(page_id_t page_id) {
  // 0.   Make sure you call DeallocatePage!
  DeallocatePage(page_id);
  // 1.   Search the page table for the requested page (P).
  // 1.   If P does not exist, return true.
  if (page_table_.find(page_id) == page_table_.end()) {
    return true;
  }
  // 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.
  frame_id_t frame_id;
  frame_id = page_table_[page_id];
  if (pages_[frame_id].pin_count_ != 0) {
    return false;
  }
  // 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.
  pages_[frame_id].page_id_ = INVALID_PAGE_ID;
  pages_[frame_id].ResetMemory();
  page_table_.erase(page_id);
  free_list_.push_back(frame_id);
  return true;
}
```

#### 3.2.2 模块结构

- BufferPoolManager 类

```c++
class BufferPoolManager {
public:
  explicit BufferPoolManager(size_t pool_size, DiskManager *disk_manager);

  ~BufferPoolManager();

  Page *FetchPage(page_id_t page_id);

  bool UnpinPage(page_id_t page_id, bool is_dirty);

  bool FlushPage(page_id_t page_id);

  Page *NewPage(page_id_t &page_id);

  bool DeletePage(page_id_t page_id);

  bool IsPageFree(page_id_t page_id);

  bool CheckAllUnpinned();

private:
  page_id_t AllocatePage();
    
  void DeallocatePage(page_id_t page_id);
    
private:
  size_t pool_size_;                                        // number of pages in buffer pool
  Page *pages_;                                             // array of pages
  DiskManager *disk_manager_;                               // pointer to the disk manager.
  std::unordered_map<page_id_t, frame_id_t> page_table_;    // to keep track of pages
  Replacer *replacer_;                                      // to find an unpinned page for replacement
  std::list<frame_id_t> free_list_;                         // to find a free page for replacement
  recursive_mutex latch_;                                   // to protect shared data structure
};
```

#### 3.2.3 模块功能

​	BufferPoolManager模块的功能是实现在缓冲池中向内存取页及刷页。

- `BufferPoolManager::FetchPage(page_id)`：根据逻辑页号获取对应的数据页，如果该数据页不在内存中，则需要从磁盘中进行读取；
- `BufferPoolManager::NewPage(&page_id)`：分配一个新的数据页，并将逻辑页号于`page_id`中返回；
- `BufferPoolManager::UnpinPage(page_id, is_dirty)`：取消固定一个数据页；
- `BufferPoolManager::FlushPage(page_id)`：将数据页转储到磁盘中；
- `BufferPoolManager::DeletePage(page_id)`：释放一个数据页；
- `BufferPoolManager::FlushAllPages()`：将所有的页面都转储到磁盘中。

## 4 INDEX MANAGER

### 4.1 实验目的

​	Index Manager 负责数据表索引的实现和管理，包括：索引的创建和删除，索引键的等值查找，索引键的范围查找（返回对应的迭代器），以及插入和删除键值等操作，并对外提供相应的接口。

​	在堆表实验中，能够发现，通过遍历堆表的方式来查找一条记录是十分低效的。为了能够快速定位到某条记录而无需搜索数据表中的每一条记录，我们需要在上一个实验的基础上实现一个索引，这能够为快速随机查找和高效访问有序记录提供基础。索引有很多种实现方式，如B+树索引，Hash索引等等。在本实验中，我们需要实现一个基于磁盘的B+树动态索引结构。

### 4.2 实验细节

#### 4.2.1 模块设计细节

- B+树数据页
  - BPlusTreePage为基类，为内部节点与叶节点提供统一的接口
  - BPlusTreeInternalPage
  - BPlusTreeLeafPage
  - KeyType、ValueType & KeyComparator

- B+树索引

​	在完成B+树结点的数据结构设计后，接下来需要完成B+树的创建、插入、删除、查找和释放等操作。

​	包括：`IsEmpty()` , `GetValue()` , `Insert()` , `StartNewTree()` , `InsertIntoLeaf()` , `Split()` , `InsertIntoParent()` , `Remove()` , `CoalesceOrRedistribute()` , `FindSibling()` , `Coalesce()` , `Redistribute()` , `AdjustRoot()` 等函数。

- B+树索引迭代器

​	在B+树索引中实现`Begin()`和`End()`函数以获取B+树索引的首迭代器和尾迭代器。

#### 4.2.2 模块结构

- BPlusTreePage类

```c++
class BPlusTreePage {
public:
  bool IsLeafPage() const;

  bool IsRootPage() const;

  void SetPageType(IndexPageType page_type);

  int GetSize() const;

  void SetSize(int size);

  void IncreaseSize(int amount);

  int GetMaxSize() const;

  void SetMaxSize(int max_size);

  int GetMinSize() const;

  page_id_t GetParentPageId() const;

  void SetParentPageId(page_id_t parent_page_id);

  page_id_t GetPageId() const;

  void SetPageId(page_id_t page_id);

  void SetLSN(lsn_t lsn = INVALID_LSN);

private:
  // member variable, attributes that both internal and leaf page share
  [[maybe_unused]] IndexPageType page_type_;
  [[maybe_unused]] lsn_t lsn_;
  [[maybe_unused]] int size_;
  [[maybe_unused]] int max_size_;
  [[maybe_unused]] page_id_t parent_page_id_;
  [[maybe_unused]] page_id_t page_id_;
};
```

- BPlusTreeInternalPage类

```c++
class BPlusTreeInternalPage : public BPlusTreePage {
public:
  // must call initialize method after "create" a new node
  void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int max_size = INTERNAL_PAGE_SIZE);

  KeyType KeyAt(int index) const;

  void SetKeyAt(int index, const KeyType &key);

  int ValueIndex(const ValueType &value) const;

  ValueType ValueAt(int index) const;

  ValueType Lookup(const KeyType &key, const KeyComparator &comparator) const;

  void PopulateNewRoot(const ValueType &old_value, const KeyType &new_key, const ValueType &new_value);

  int InsertNodeAfter(const ValueType &old_value, const KeyType &new_key, const ValueType &new_value);

  void Remove(int index);

  ValueType RemoveAndReturnOnlyChild();

  // Split and Merge utility methods
  void MoveAllTo(BPlusTreeInternalPage *recipient, const KeyType &middle_key, BufferPoolManager *buffer_pool_manager);

  void MoveHalfTo(BPlusTreeInternalPage *recipient, BufferPoolManager *buffer_pool_manager);

  void MoveFirstToEndOf(BPlusTreeInternalPage *recipient, const KeyType &middle_key,
                        BufferPoolManager *buffer_pool_manager);

  void MoveLastToFrontOf(BPlusTreeInternalPage *recipient, const KeyType &middle_key,
                         BufferPoolManager *buffer_pool_manager);

private:
  void CopyNFrom(MappingType *items, int size, BufferPoolManager *buffer_pool_manager);

  void CopyLastFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager);

  void CopyFirstFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager);

  // 注意array_[0] 的key总是是无效的
  MappingType array_[0];
};
```

- BPlusTreeLeafPage类

```c++
class BPlusTreeLeafPage : public BPlusTreePage {
public:
  // After creating a new leaf page from buffer pool, must call initialize
  // method to set default values
  void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int max_size = LEAF_PAGE_SIZE);

  // helper methods
  page_id_t GetNextPageId() const;

  void SetNextPageId(page_id_t next_page_id);

  KeyType KeyAt(int index) const;

  int KeyIndex(const KeyType &key, const KeyComparator &comparator) const;

  const MappingType &GetItem(int index);

  // insert and delete methods
  int Insert(const KeyType &key, const ValueType &value, const KeyComparator &comparator);

  bool Lookup(const KeyType &key, ValueType &value, const KeyComparator &comparator) const;

  int RemoveAndDeleteRecord(const KeyType &key, const KeyComparator &comparator);

  // Split and Merge utility methods
  void MoveHalfTo(BPlusTreeLeafPage *recipient);

  void MoveAllTo(BPlusTreeLeafPage *recipient);

  void MoveFirstToEndOf(BPlusTreeLeafPage *recipient);

  void MoveLastToFrontOf(BPlusTreeLeafPage *recipient);

private:
  void CopyNFrom(MappingType *items, int size);

  void CopyLastFrom(const MappingType &item);

  void CopyFirstFrom(const MappingType &item);

  page_id_t next_page_id_;
  // 应该保证叶节点内pair的value都是INVALID_PAGE_ID
  MappingType array_[0];
};
```

- BPlusTree类

```c++
class BPlusTree {
  using InternalPage = BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator>;
  using LeafPage = BPlusTreeLeafPage<KeyType, ValueType, KeyComparator>;

 public:
  explicit BPlusTree(index_id_t index_id, BufferPoolManager *buffer_pool_manager, const KeyComparator &comparator,
                     int leaf_max_size = LEAF_PAGE_SIZE, int internal_max_size = INTERNAL_PAGE_SIZE);

  // Returns true if this B+ tree has no keys and values.
  bool IsEmpty() const;

  // Insert a key-value pair into this B+ tree.
  bool Insert(const KeyType &key, const ValueType &value, Transaction *transaction = nullptr);

  // Remove a key and its value from this B+ tree.
  void Remove(const KeyType &key, Transaction *transaction = nullptr);

  // return the value associated with a given key
  bool GetValue(const KeyType &key, std::vector<ValueType> &result, Transaction *transaction = nullptr);

  void SetRootId(page_id_t root_page_id) { root_page_id_ = root_page_id; }

  INDEXITERATOR_TYPE Begin();

  INDEXITERATOR_TYPE Begin(const KeyType &key);

  INDEXITERATOR_TYPE End();

  // expose for test purpose
  Page *FindLeafPage(const KeyType &key, bool leftMost = false);

  // used to check whether all pages are unpinned
  bool Check();

  // destroy the b plus tree
  void Destroy();

  void PrintTree(std::ofstream &out) {
    if (IsEmpty()) {
      return;
    }
    out << "digraph G {" << std::endl;
    Page *root_page = buffer_pool_manager_->FetchPage(root_page_id_);
    BPlusTreePage *node = reinterpret_cast<BPlusTreePage *>(root_page);
    ToGraph(node, buffer_pool_manager_, out);
    out << "}" << std::endl;
    buffer_pool_manager_->UnpinPage(root_page_id_, false);
  }

  void UpdateRootPageId(int insert_record = 0);

 private:
  BPlusTreePage *FetchPage(page_id_t page_id);

  void StartNewTree(const KeyType &key, const ValueType &value);

  bool InsertIntoLeaf(const KeyType &key, const ValueType &value, Transaction *transaction = nullptr);

  void InsertIntoParent(BPlusTreePage *old_node, const KeyType &key, BPlusTreePage *new_node,
                        Transaction *transaction = nullptr);

  template <typename N>
  N *Split(N *node);

  template <typename N>
  bool CoalesceOrRedistribute(N *node, Transaction *transaction = nullptr);

  template <typename N>
  bool FindSibling(N *node, N *&sibling);

  template <typename N>
  bool Coalesce(N **neighbor_node, N **node, BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator> **parent,
                int index, Transaction *transaction = nullptr);

  template <typename N>
  void Redistribute(N *neighbor_node, N *node, int index);

  bool AdjustRoot(BPlusTreePage *node);

  /* Debug Routines for FREE!! */
  void ToGraph(BPlusTreePage *page, BufferPoolManager *bpm, std::ofstream &out) const;

  void ToString(BPlusTreePage *page, BufferPoolManager *bpm) const;

  // member variable
  index_id_t index_id_;
  page_id_t root_page_id_;
  BufferPoolManager *buffer_pool_manager_;
  KeyComparator comparator_;
  int leaf_max_size_;
  int internal_max_size_;
};
```

#### 4.2.3 模块功能

 INDEX MANAGER模块提供了对任意Key 和 Value 建索引的方法和接口，能够实现对数据生成b+树索引，从而在对于有索引的数据进行查询时能够大大的加快速度，而不用对堆表进行遍历。

## 5 Executor

### 5.1 实验目的

Executor（执行器）的主要功能是根据解释器（Parser）生成的语法树，通过Catalog Manager 提供的信息生成执行计划，并调用 Record Manager、Index Manager 和 Catalog Manager 提供的相应接口进行执行，最后通过执行上下文`ExecuteContext`将执行结果返回给上层模块。

### 5.2 实验细节

#### 5.2.1 模块设计细节

- ExecutorEngine构造函数

  ```cpp
  ExecuteEngine::ExecuteEngine() {
    fstream list_file;
    list_file.open(LIST_FILE, std::ios::binary | std::ios::in);
    char DB_name[MAX_FILE_NAME_LENGTH], DB_path[MAX_FILE_NAME_LENGTH];
    if (list_file.is_open()) {
      list_file.getline(DB_name, MAX_FILE_NAME_LENGTH);
      while (strcmp(DB_name, "")) {
        strcpy(DB_path, DB_name);
        strcat(DB_path, ".db");
        auto DB_ptr = new DBStorageEngine(DB_path, false);
        dbs_.insert(make_pair(DB_name, DB_ptr));
        list_file.getline(DB_name, MAX_FILE_NAME_LENGTH);
      }
    }
    current_db_ = "";
  }
  ```

- ExecuteContext结构体定义

  ```c++
  struct ExecuteContext {
    bool flag_quit_{false};
    Transaction *txn_{nullptr};
    string table_name_;
    //中间节点返回的临时表
    std::set<RowId> internal_result_rid_;
    //select需要输出的列
    std::vector<Column *> select_columns_;
    //执行信息输出相关变量
    int print_flag;
    bool dont_print = false;
    struct timeval start;
    int rows_num = 0;
  };
  ```

#### 5.2.2 模块结构

执行器对外的接口仅有一个`dberr_t Execute(pSyntaxNode ast, ExecuteContext *context)`，语法树中的节点又可以分为两类：

- 顶层节点，包括Select、CreateDatabase等，与SQL语句一一对应。
- 下层节点，包括CompareOperator、Connector等，负责为顶层节点筛选符合条件的tuples并在context中返回。

```cpp
class ExecuteEngine {
 public:
  ExecuteEngine();

  ~ExecuteEngine() {
    fstream list_file;
    list_file.open(LIST_FILE, std::ios::binary | std::ios::out);
    for (auto it : dbs_) {
      list_file << it.first << '\n';
      delete it.second;
    }
  }

  /**
   * executor interface
   */
  dberr_t Execute(pSyntaxNode ast, ExecuteContext *context);

 private:
  dberr_t ExecuteCreateDatabase(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDropDatabase(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteShowDatabases(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteUseDatabase(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteShowTables(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteCreateTable(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDropTable(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteShowIndexes(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteCreateIndex(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDropIndex(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteSelect(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteInsert(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteDelete(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteUpdate(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteTrxBegin(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteTrxCommit(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteTrxRollback(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteExecfile(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteQuit(pSyntaxNode ast, ExecuteContext *context);

 private:
  dberr_t ExecuteInternalNode(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteCompareOperator(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteAllColumn(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteColumnList(pSyntaxNode ast, ExecuteContext *context);

  dberr_t ExecuteConnector(pSyntaxNode ast, ExecuteContext *context);

  std::unordered_map<std::string, DBStorageEngine *> dbs_; /** all opened databases */
  std::string current_db_;                                 /** current database */
};
```

#### 5.2.3 模块功能

在Parser模块调用`yyparse()`完成SQL语句解析后，将会得到语法树的根结点`pSyntaxNode`，将语法树根结点传入执行器`ExecuteEngine`后，`ExecuteEngine`将会根据语法树根结点的类型，分发到对应的执行函数中，以完成不同类型SQL语句的执行。

本节完善了Executor内部所有的执行函数以支持其对应的功能。

## 6 RECORD MANAGER

### 6.1 实验目的

​	Record Manager负责管理数据表中所有的记录，包括`列(Column)`、`模式(Schema)`、`域(Field)`、`行(Row)`，它可以支持这些记录的插入、删除和查找操作，并且对外提供相应的接口。为了能够持久化这些记录，我们需要将这些对象序列化成`字节流(char*)`的方法，为了从磁盘中恢复这些对象，我们需要从字节流反序列化恢复这些记录对象。同时我们具体通过堆表进行记录的管理。

### 6.2 实验细节

#### 6.2.1 模块设计细节

​	由于filed里的数据具有三种类型：`kTypeInt`、`kTypeFloat`、`kTypeChar`，对于field的每个操作都要针对每个类型实现一次。

​	对于一些长度不确定的数据类型序列化时，需要将它的长度先序列化，然后再将其序列化。与之相对的，在反序列化时，先读出其长度，然后根据长度重建该数据。以下代码例子展示该细节：

```c++
uint32_t Schema::SerializeTo(char *buf) const {
  uint32_t ofs = 0,move;
  MACH_WRITE_INT32(buf,this->SCHEMA_MAGIC_NUM);
  move = sizeof(uint32_t);
  ofs += move;buf += move;
  //因为columns_是一个vector类型的数据，长度可变，先把columns_的大小先写入内存
  MACH_WRITE_UINT32(buf,columns_.size());
  move = sizeof(uint32_t);
  ofs += move;buf += move;
  for(auto column:this->columns_){
    move = column->SerializeTo(buf);
    ofs += move;buf += move;
  }
  return ofs;
}

uint32_t Schema::DeserializeFrom(char *buf, Schema *&schema, MemHeap *heap) {
  uint32_t ofs = 0,move;
  uint32_t magic_num = MACH_READ_UINT32(buf);
  move = sizeof(uint32_t);
  ofs += move;buf += move; 
  if(magic_num!=schema->SCHEMA_MAGIC_NUM)                //check the schema magic number
    LOG(ERROR)<<"SCHEMA_MAGIC_NUM doesn't match!"<<std::endl;
  uint32_t size = MACH_READ_UINT32(buf);		//在反序列化时把先columns_的大小读出
  move = sizeof(uint32_t);
  ofs += move;buf += move;
  std::vector<Column*> columns_;
  for(auto i=0;i<size;i++){						//根据大小构建columns_
    Column* column = nullptr;
    move = Column::DeserializeFrom(buf,column,heap);
    columns_.push_back(column);
    ofs += move;buf += move;
  }
  schema = new Schema(columns_);
  return ofs;
}
```

#### 6.2.2 模块结构

​	四种记录中，`field`是最基础的，对应于一条记录中某一个字段的数据信息。`column`用于定义和表示数据表中的某一个字段，包含字段名、字段类型、是否唯一等。`schema`由多个column组成，表示表或索引的结构，而`row`与元组的概念等价，用于存储记录或索引键。

​	下面用一个示意图表示他们的关系：

![struct](../Desktop/minisql/pic\struct.jpg)

column类：

```c++
class Column {
  friend class Schema;

public:
  Column(std::string column_name, TypeId type, uint32_t index, bool nullable, bool unique);

  Column(std::string column_name, TypeId type, uint32_t length, uint32_t index, bool nullable, bool unique);

  Column(const Column *other);

  std::string GetName() const { return name_; }

  uint32_t GetLength() const { return len_; }

  void SetTableInd(uint32_t ind) { table_ind_ = ind; }

  uint32_t GetTableInd() const { return table_ind_; }

  bool IsNullable() const { return nullable_; }

  TypeId GetType() const { return type_; }

  uint32_t SerializeTo(char *buf) const;

  uint32_t GetSerializedSize() const;

  static uint32_t DeserializeFrom(char *buf, Column *&column, MemHeap *heap);

  bool IsUnique();

 private:
  static constexpr uint32_t COLUMN_MAGIC_NUM = 210928;
  std::string name_;
  TypeId type_;
  uint32_t len_{0};       // for char type this is the maximum byte length of the string data,
  // otherwise is the fixed size
  uint32_t table_ind_{0}; // column position in table
  bool nullable_{false};  // whether the column can be null
  bool unique_{false};    // whether the column is unique
};
```

schema类：

```c++
class Schema {
public:
  explicit Schema(const std::vector<Column *> columns) : columns_(std::move(columns)) {}

  inline const std::vector<Column *> &GetColumns() const { return columns_; }

  inline const Column *GetColumn(const uint32_t column_index) const { return columns_[column_index]; }

  dberr_t GetColumnIndex(const std::string &col_name, uint32_t &index) const {
    for (uint32_t i = 0; i < columns_.size(); ++i) {
      if (columns_[i]->GetName() == col_name) {
        index = i;
        return DB_SUCCESS;
      }
    }
    return DB_COLUMN_NAME_NOT_EXIST;
  }

  inline uint32_t GetColumnCount() const { return static_cast<uint32_t>(columns_.size()); }

  /**
   * Shallow copy schema, only used in index
   *
   * @param: attrs Column index map from index to tuple
   * eg: Tuple(A, B, C, D)  Index(D, A) ==> attrs(3, 0)
   */
  static Schema *ShallowCopySchema(const Schema *table_schema, const std::vector<uint32_t> &attrs, MemHeap *heap) {
    std::vector<Column *> cols;
    cols.reserve(attrs.size());
    for (const auto i : attrs) {
      cols.emplace_back(table_schema->columns_[i]);
    }
    void *buf = heap->Allocate(sizeof(Schema));
    return new(buf) Schema(cols);
  }

  /**
   * Deep copy schema
   */
  static Schema *DeepCopySchema(const Schema *from, MemHeap *heap) {
    std::vector<Column *> cols;
    for (uint32_t i = 0; i < from->GetColumnCount(); i++) {
      void *buf = heap->Allocate(sizeof(Column));
      cols.push_back(new(buf)Column(from->GetColumn(i)));
    }
    void *buf = heap->Allocate(sizeof(Schema));
    return new(buf) Schema(cols);
  }

  /**
   * Only used in table
   */
  uint32_t SerializeTo(char *buf) const;

  /**
   * Only used in table
   */
  uint32_t GetSerializedSize() const;

  /**
   * Only used in table
   */
  static uint32_t DeserializeFrom(char *buf, Schema *&schema, MemHeap *heap);

private:
  static constexpr uint32_t SCHEMA_MAGIC_NUM = 200715;
  std::vector<Column *> columns_;   /** don't need to delete pointer to column */
};
```

row类：

```c++
class Row {
public:
  explicit Row(std::vector<Field> &fields) : heap_(new SimpleMemHeap) {
    // deep copy
    for (auto &field : fields) {
      void *buf = heap_->Allocate(sizeof(Field));
      fields_.push_back(new(buf)Field(field));
    }
  }

  /**
   * Row used for deserialize
   */
  Row() = default;

  /**
   * Row used for deserialize and update
   */
  Row(RowId rid) : rid_(rid), heap_(new SimpleMemHeap) {}

  /**
   * Row copy function
   */
  Row(const Row &other) : heap_(new SimpleMemHeap) {
    if (!fields_.empty()) {
      for (auto &field : fields_) {
        heap_->Free(field);
      }
      fields_.clear();
    }
    rid_ = other.rid_;
    for (auto &field : other.fields_) {
      void *buf = heap_->Allocate(sizeof(Field));
      fields_.push_back(new(buf)Field(*field));
    }
  }

  virtual ~Row() {
    delete heap_;
  }

  /**
   * Note: Make sure that bytes write to buf is equal to GetSerializedSize()
   */
  uint32_t SerializeTo(char *buf, Schema *schema) const;

  uint32_t DeserializeFrom(char *buf, Schema *schema);

  /**
   * For empty row, return 0
   * For non-empty row with null fields, eg: |null|null|null|, return header size only
   * @return
   */
  uint32_t GetSerializedSize(Schema *schema) const;

  inline const RowId GetRowId() const { return rid_; }

  inline void SetRowId(RowId rid) { rid_ = rid; }

  inline std::vector<Field *> &GetFields() { return fields_; }

  inline Field *GetField(uint32_t idx) const {
    ASSERT(idx < fields_.size(), "Failed to access field");
    return fields_[idx];
  }

  inline size_t GetFieldCount() const { return fields_.size(); }

private:
  RowId rid_{};
  std::vector<Field *> fields_;   /** Make sure that all fields are created by mem heap */
  MemHeap *heap_{nullptr};
};
```

tableHeap类:

```c++
class TableHeap {
  friend class TableIterator;

 public:
  static TableHeap *Create(BufferPoolManager *buffer_pool_manager, Schema *schema, Transaction *txn,
                           LogManager *log_manager, LockManager *lock_manager, MemHeap *heap) {
    void *buf = heap->Allocate(sizeof(TableHeap));
    return new (buf) TableHeap(buffer_pool_manager, schema, txn, log_manager, lock_manager);
  }

  static TableHeap *Create(BufferPoolManager *buffer_pool_manager, page_id_t first_page_id, Schema *schema,
                           LogManager *log_manager, LockManager *lock_manager, MemHeap *heap) {
    void *buf = heap->Allocate(sizeof(TableHeap));
    return new (buf) TableHeap(buffer_pool_manager, first_page_id, schema, log_manager, lock_manager);
  }

  ~TableHeap() {}

  bool InsertTuple(Row &row, Transaction *txn);

  bool MarkDelete(const RowId &rid, Transaction *txn);

  bool UpdateTuple(Row &new_row, const RowId &rid, Transaction *txn);

  void ApplyDelete(const RowId &rid, Transaction *txn);

  void RollbackDelete(const RowId &rid, Transaction *txn);

  bool GetTuple(Row *row, Transaction *txn);

  void FreeHeap();

  TableIterator Begin(Transaction *txn);

  TableIterator End();
    
  inline page_id_t GetFirstPageId() const { return first_page_id_; }

 private:
  explicit TableHeap(BufferPoolManager *buffer_pool_manager, Schema *schema, Transaction *txn, LogManager *log_manager,
                     LockManager *lock_manager)
      : buffer_pool_manager_(buffer_pool_manager),
        schema_(schema),
        log_manager_(log_manager),
        lock_manager_(lock_manager) {
    //ASSERT(false, "Not implemented yet.");
    page_id_t page_id;
    buffer_pool_manager_->NewPage(page_id);
    first_page_id_ = page_id;
    auto page = reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(page_id));
    page->Init(page_id, INVALID_PAGE_ID, nullptr, nullptr);
    buffer_pool_manager_->UnpinPage(page_id, true);
    buffer_pool_manager_->UnpinPage(page_id, true);
  }

  /**
   * load existing table heap by first_page_id
   */
  explicit TableHeap(BufferPoolManager *buffer_pool_manager, page_id_t first_page_id, Schema *schema,
                     LogManager *log_manager, LockManager *lock_manager)
      : buffer_pool_manager_(buffer_pool_manager),
        first_page_id_(first_page_id),
        schema_(schema),
        log_manager_(log_manager),
        lock_manager_(lock_manager) {}

 private:
  BufferPoolManager *buffer_pool_manager_;
  page_id_t first_page_id_;
  Schema *schema_;
  [[maybe_unused]] LogManager *log_manager_;
  [[maybe_unused]] LockManager *lock_manager_;
};
```

#### 6.2.3 模块功能

通过Record Manager模块的设计，我们可以向表中插入、删除和查找记录。其中：

* `TableHeap::InsertTuple(&row,*txn)`: 向数据表中插入一个row。
* `TableHeap::MarkDelete(&rid,*txn)`: 将数据表中的一个row标记为被删除。
* `TableHeap::UpdateTuple(&new_row,&rid,*txn)`: 用新的row更新已有的row。
* `TableHeap::GetTuple(*row,*txn)`: 在数据表中读一个row。

## 7 CATALOG MANAGER

### 7.1 实验目的

​	Catalog Manager 管理和维护数据库中的所有表和索引的信息，主要包括`表信息(TableInfo)`和`索引信息(IndexInfo)`两种，每种信息中包含了名称、字段、主键等定义。该模块调用下层接口实现创建、更新、删除等功能，并为上层的执行器`Executor`提供接口。

​	表和索引的信息中最核心的部分是表和索引的元信息，根据元信息可以生成或恢复整个表和索引信息，所以在创建和后续重新打开数据库实例恢复信息时主要需要得到元信息，因此对相关元信息实现序列化和反序列化操作。

​	在`CatalogManager`、`TableInfo`、`IndexInfo`中都通过各自的`heap`维护和管理与自身相关的内存分配和回收，在析构时，其相关对象会跟随一起析构，而不需要手动管理。

### 7.2 实验细节

####  7.2.1 模块设计细节

​	索引需要在表的基础上建立，因此索引信息类中包含了表信息，要先创建了表之后才能创建索引。而在删除表时，需要先删除该表的所有索引之后，才能删除该表。

​	Catalog Manager中的表和索引的信息用c++中的map容器存放，通过表名或索引名可以查到其id，通过id可以查找存放表和索引数据的page_id。

Catalog Manager：

```c++
class CatalogMeta {
  friend class CatalogManager;

public:
  void SerializeTo(char *buf) const;

  static CatalogMeta *DeserializeFrom(char *buf, MemHeap *heap);

  uint32_t GetSerializedSize() const;

  inline table_id_t GetNextTableId() const {
    return table_meta_pages_.size() == 0 ? 0 : table_meta_pages_.rbegin()->first;
  }

  inline index_id_t GetNextIndexId() const {
    return index_meta_pages_.size() == 0 ? 0 : index_meta_pages_.rbegin()->first;
  }

  static CatalogMeta *NewInstance(MemHeap *heap) {
    void *buf = heap->Allocate(sizeof(CatalogMeta));
    return new(buf) CatalogMeta();
  }

private:
  explicit CatalogMeta();

private:
  static constexpr uint32_t CATALOG_METADATA_MAGIC_NUM = 89849;
  std::map<table_id_t, page_id_t> table_meta_pages_;
  std::map<index_id_t, page_id_t> index_meta_pages_;
};

/**
 * Catalog manager
 *
 */
class CatalogManager {
public:
  explicit CatalogManager(BufferPoolManager *buffer_pool_manager, LockManager *lock_manager,
                          LogManager *log_manager, bool init);

  ~CatalogManager();

  dberr_t CreateTable(const std::string &table_name, TableSchema *schema, Transaction *txn, TableInfo *&table_info);

  dberr_t GetTable(const std::string &table_name, TableInfo *&table_info);

  dberr_t GetTables(std::vector<TableInfo *> &tables) const;

  dberr_t CreateIndex(const std::string &table_name, const std::string &index_name,
                      const std::vector<std::string> &index_keys, Transaction *txn,
                      IndexInfo *&index_info);

  dberr_t GetIndex(const std::string &table_name, const std::string &index_name, IndexInfo *&index_info) const;

  dberr_t GetTableIndexes(const std::string &table_name, std::vector<IndexInfo *> &indexes) const;

  dberr_t DropTable(const std::string &table_name);

  dberr_t DropIndex(const std::string &table_name, const std::string &index_name);

private:
  dberr_t FlushCatalogMetaPage() const;

  dberr_t LoadTable(const table_id_t table_id, const page_id_t page_id);

  dberr_t LoadIndex(const index_id_t index_id, const page_id_t page_id);

  dberr_t GetTable(const table_id_t table_id, TableInfo *&table_info);

private:
  [[maybe_unused]] BufferPoolManager *buffer_pool_manager_;
  [[maybe_unused]] LockManager *lock_manager_;
  [[maybe_unused]] LogManager *log_manager_;
  [[maybe_unused]] CatalogMeta *catalog_meta_;
  [[maybe_unused]] std::atomic<table_id_t> next_table_id_;
  [[maybe_unused]] std::atomic<index_id_t> next_index_id_;
  // map for tables
  std::unordered_map<std::string, table_id_t> table_names_;
  std::unordered_map<table_id_t, TableInfo *> tables_;
  // map for indexes: table_name_->index_name->indexes
  [[maybe_unused]] std::unordered_map<std::string, std::unordered_map<std::string, index_id_t>> index_names_;
  [[maybe_unused]] std::unordered_map<index_id_t, IndexInfo *> indexes_;
  // memory heap
  MemHeap *heap_;
};
```

#### 7.2.2 模块结构

Catalog Manager模块的结构图：

![struct1](../Desktop/minisql/pic\struct1.png)

* TableMeta类

  ```c++
  class TableMetadata {
    friend class TableInfo;
  
  public:
    uint32_t SerializeTo(char *buf) const;
  
    uint32_t GetSerializedSize() const;
  
    static uint32_t DeserializeFrom(char *buf, TableMetadata *&table_meta, MemHeap *heap);
  
    static TableMetadata *Create(table_id_t table_id, std::string table_name,
                                 page_id_t root_page_id, TableSchema *schema, MemHeap *heap);
  
    inline table_id_t GetTableId() const { return table_id_; }
  
    inline std::string GetTableName() const { return table_name_; }
  
    inline uint32_t GetFirstPageId() const { return root_page_id_; }
  
    inline Schema *GetSchema() const { return schema_; }
  
  
  private:
    TableMetadata() = delete;
  
    TableMetadata(table_id_t table_id, std::string table_name, page_id_t root_page_id, TableSchema *schema);
  
  private:
    static constexpr uint32_t TABLE_METADATA_MAGIC_NUM = 344528;
    table_id_t table_id_;
    std::string table_name_;
    page_id_t root_page_id_;
    Schema *schema_;
  };
  ```

* TableInfo类

  ```c++
  class TableInfo {
  public:
    static TableInfo *Create(MemHeap *heap) {
      void *buf = heap->Allocate(sizeof(TableInfo));
      return new(buf)TableInfo();
    }
  
    ~TableInfo() {
      delete heap_;
    }
  
    void Init(TableMetadata *table_meta, TableHeap *table_heap) {
      table_meta_ = table_meta;
      table_heap_ = table_heap;
    }
  
    inline TableHeap *GetTableHeap() const { return table_heap_; }
  
    inline MemHeap *GetMemHeap() const { return heap_; }
  
    inline table_id_t GetTableId() const { return table_meta_->table_id_; }
  
    inline std::string GetTableName() const { return table_meta_->table_name_; }
  
    inline Schema *GetSchema() const { return table_meta_->schema_; }
  
    inline page_id_t GetRootPageId() const { return table_meta_->root_page_id_; }
  
  private:
    explicit TableInfo() : heap_(new SimpleMemHeap()) {};
  
  private:
    TableMetadata *table_meta_;
    TableHeap *table_heap_;
    MemHeap *heap_; /** store all objects allocated in table_meta and table heap */
  };
  ```

* IndexMeta类

  ```c++
  class IndexMetadata {
    friend class IndexInfo;
  
   public:
    static IndexMetadata *Create(const index_id_t index_id, const std::string &index_name, const table_id_t table_id,
                                 const std::vector<uint32_t> &key_map, MemHeap *heap);
  
    uint32_t SerializeTo(char *buf) const;
  
    uint32_t GetSerializedSize() const;
  
    static uint32_t DeserializeFrom(char *buf, IndexMetadata *&index_meta, MemHeap *heap);
  
    inline std::string GetIndexName() const { return index_name_; }
  
    inline table_id_t GetTableId() const { return table_id_; }
  
    uint32_t GetIndexColumnCount() const { return key_map_.size(); }
  
    inline const std::vector<uint32_t> &GetKeyMapping() const { return key_map_; }
  
    inline index_id_t GetIndexId() const { return index_id_; }
  
   private:
    IndexMetadata() = delete;
  
    explicit IndexMetadata(const index_id_t index_id, const std::string &index_name, const table_id_t table_id,
                           const std::vector<uint32_t> &key_map)
        : index_id_(index_id), index_name_(index_name), table_id_(table_id), key_map_(key_map) {}
  
   private:
    static constexpr uint32_t INDEX_METADATA_MAGIC_NUM = 344528;
    index_id_t index_id_;
    std::string index_name_;
    table_id_t table_id_;
    std::vector<uint32_t> key_map_; /** The mapping of index key to tuple key */
  };
  ```

* IndexInfo类

  ```c++
  class IndexInfo {
   public:
    static IndexInfo *Create(MemHeap *heap) {
      void *buf = heap->Allocate(sizeof(IndexInfo));
      return new (buf) IndexInfo();
    }
  
    ~IndexInfo() { delete heap_; }
  
    void Init(IndexMetadata *meta_data, TableInfo *table_info, BufferPoolManager *buffer_pool_manager) {
      // Step1: init index metadata and table info
      meta_data_ = meta_data;
      table_info_ = table_info;
      // Step2: mapping index key to key schema
      key_schema_ = Schema::ShallowCopySchema(table_info->GetSchema(), meta_data->GetKeyMapping(), heap_);
      // Step3: call CreateIndex to create the index
      index_ = CreateIndex(buffer_pool_manager);
    }
  
    inline BPlusTreeIndex<INDEX_KEY_TYPE, RowId, INDEX_COMPARATOR_TYPE> *GetIndex() { return index_; }
  
    inline std::string GetIndexName() { return meta_data_->GetIndexName(); }
  
    inline IndexSchema *GetIndexKeySchema() { return key_schema_; }
  
    inline MemHeap *GetMemHeap() const { return heap_; }
  
    inline TableInfo *GetTableInfo() const { return table_info_; }
  
   private:
    explicit IndexInfo()
        : meta_data_{nullptr}, index_{nullptr}, table_info_{nullptr}, key_schema_{nullptr}, heap_(new SimpleMemHeap()) {}
  
    BPlusTreeIndex<INDEX_KEY_TYPE, RowId, INDEX_COMPARATOR_TYPE> *CreateIndex(BufferPoolManager *buffer_pool_manager) {
      BPlusTreeIndex<INDEX_KEY_TYPE, RowId, INDEX_COMPARATOR_TYPE> *bpt =
          new BPlusTreeIndex<INDEX_KEY_TYPE, RowId, INDEX_COMPARATOR_TYPE>(meta_data_->GetIndexId(), key_schema_,
                                                                           buffer_pool_manager);
  
      return bpt;
    }
  
   private:
    IndexMetadata *meta_data_;
    BPlusTreeIndex<INDEX_KEY_TYPE, RowId, INDEX_COMPARATOR_TYPE> *index_;
    TableInfo *table_info_;
    IndexSchema *key_schema_;
    MemHeap *heap_;
  };
  ```

#### 7.2.3 模块功能

Catalog Manager对上层模块提供了一些接口，方便执行器获取目录信息并生成执行计划：

* `CatalogManager::CreateTable`: 通过表名和schema生成TableInfo。
* `CatalogManager::GetTable:` 通过表名得到TableInfo。
* `CatalogManager::GetTables`: 获取包含所有数据表的vector。
* `CatalogManager::CreateIndex`: 通过表名、索引名和表与索引的映射关系生成IndexInfo。
* `CatalogManager::GetIndex:`：通过索引名得到IndexInfo。
* `CatalogManager::DropTable`: 通过表名删除TableInfo和CatalogManger中的相关表信息。
* `CatalogManager::DropIndex`: 通过索引名删除Indexinfo和CatalogManager中的相关索引信息。

